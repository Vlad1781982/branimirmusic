s marked with DataMemberAttribute attribute must have unique names.FCannot import invalid schemas. Compilation on the XmlSchemaSet failed.ECannot import type for null XmlQualifiedName specified via parameter.OCannot import null XmlSchema contained in XmlSchemaSet specified via parameter.Cannot load member type '{0}'.gObject graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.¯Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.¬Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.µCollection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.ôDataContractJsonSerializer does not support the setting of the FullTypeName of the object to be serialized to a value other than the default FullTypeName. Attempted to serialize object with full type name '{0}' and default full type name '{1}'.rAn internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.EIt contains a circular reference for type '{0}' from namespace '{1}'.øThe use of type '{0}' as a get-only collection is not supported with NetDataContractSerializer.  Consider marking the type with the CollectionDataContractAttribute attribute or the SerializableAttribute attribute or adding a setter to the property.æThe deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.ƒ'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)7Collection type '{0}' does not have a valid Add method.ACollection type '{0}' does not have a valid GetEnumerator method.5Collection type '{0}' must have a non-null item type.2{0} is a built-in type and cannot be a collection.({0} has DataContractAttribute attribute.B{0} does not have a valid Add method with parameter of type '{1}'.({0} does not have a default constructor.0{0} has multiple definitions of interface '{1}'.-{0} does not implement IEnumerable interface.MThe combined length of the prefix and namespace must not be greater than {0}.4Complex types derived by restriction not supported. ›DataContractSerializer config section under System.Runtime.Serialization section group could not be loaded. Verify that machine.config is correctly set up.¥Configuration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains an index value '{0}' that is out of range.éConfiguration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains an invalid 'parameter' element. You can only add to its parameters collection when the 'type' property is set.ÜConfiguration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains a 'parameter' element that has both 'index' and 'type' set. You can only set one of these values.ÛConfiguration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains a 'parameter' element that has neither 'index' nor 'type' set. You must set one of these values.tAn internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.<An internal error has occurred. DataContract cache overflow.´ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.1DataContract namespace '{0}' is not a valid URI. GDataContract namespace '{0}' cannot be specified since it is reserved. _Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. €Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to DataContractSerializer.¬Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializer.­Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.0Default value on element '{0}' is not supported.TIt is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.@Deserialized object with reference id '{0}' not found in stream.ÄDataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.äType '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List<Test> and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.ÜType '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.ÎThe collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.èType '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.ÂDataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.FInvalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.AInvalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.ZInvalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.''maxOccurs' on element '{0}' must be 1.,'minOccurs' on element '{0}' must be 0 or 1.9Ref to element '{0}' in '{1}' namespace is not supported.:{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. 5Enumeration facets without 'value' are not supported.jAnonymous type with <list> cannot be used to create Flags enumeration because it is not a valid enum type.NSimple type list must contain an anonymous type specifying enumeration facets.7Facets other than enumeration facets are not supported.qAnonymous type with <restriction> cannot be used to create Flags enumeration because it is not a valid enum type.:Enum type '{0}' in namespace '{1}' cannot be imported. {2}{Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. ’DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.lAnonymous type with <union>. cannot be used to create Flags enumeration because it is not a valid enum type.4There was an error deserializing the object {0}. {1}Error in line {0} position {1}.<There was an error checking start element of object {0}. {1}2There was an error serializing the object {0}. {1}of type {0}9There was an error writing end element of object {0}. {1};There was an error writing start element of object {0}. {1}¡Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. -Expecting element '{1}' from namespace '{0}'.0Expecting state '{0}' when ReadObject is called.Expecting End'{0}'.Expecting state '{0}'.KIExtensibleDataObject property setter '{1}' in type '{0}' must return void.eIExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.‡Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.KFactory type '{0}' for ISerializable type '{1}' must also be ISerializable..Fixed value on element '{0}' is not supported.:Cannot write to a buffer which is currently being flushed.(Form on element '{0}' must be qualified.?Annotation for generic type '{0}' did not have attribute '{1}'.rNested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.™Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.TAnnotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.øThe data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.þIn the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.hDataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.ªType '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.öCollection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection<T>.«An object of type '{0}' which implements IObjectReference returned null from its GetRealObject method. Change the GetRealObject implementation to return a non-null value. ÅType '{0}' has set its ISerializable assembly name to "0". "0" is an invalid assembly name. Consider using the full name of mscorlib if you would like your type to be deserialized in that assembly.LType '{0}' cannot be ISerializable and have DataContractAttribute attribute.2Its root sequence contains more than one particle.9Derived ISerializable types cannot contain any particles.@It does not contain root sequence with a wildcard element <any>.<It does not reference attribute '{0}' from namespace '{1}'. EISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'2'maxOccurs' on the wildcard element must be '{0}'.2'minOccurs' on the wildcard element must be '{0}'.0Namespace on the wildcard element must be '{0}'.6ProcessContents on the wildcard element must be '{0}'.YType '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.OType '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.CThis method cannot be called from IXmlSerializable implementations.‡IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.:IXmlSerializable Type '{0}' must have default constructor.IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.ŸThe IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.oProperty '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.cInterface type '{0}' cannot be created. Consider replacing with a non-interface serializable type. hAnnotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.~'{0}' is an invalid value for AssemblyFormat. Only FormatterAssemblyStyle.Full or FormatterAssemblyStyle.Simple are supported.€The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.$Encountered invalid character '{0}'.ÍType '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.”ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. fType '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.eType '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.µThe collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.bType '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.WType '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.gType '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.¹The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.`Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it1Type '{0}' is an invalid collection type since itXType '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.MType '{0}' cannot have DataContractAttribute attribute Namespace set to null.fMember '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.@'{0}' is an invalid data node when deserializing extension data.»Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.YType '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.`'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.ÕInvalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.ÙEnum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.gType '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. >CLR namespace '{0}' cannot have ContractNamespace set to null.ŠCannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.+Invalid Id '{0}'. Must be positive integer.RThe inclusive namespace prefix collection cannot contain null as one of the items.¼It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.¥It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.+The empty string is not a valid local name.ØMember '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' me